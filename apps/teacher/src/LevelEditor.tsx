import * as React from 'react';
import * as Engine from '../../../packages/engine/src/index.ts';

type LevelDefinition = Engine.LevelDefinition;
type Tile = Engine.Tile;
type Direction = Engine.Direction;

interface LevelEditorProps {
  initialLevel?: Partial<LevelDefinition>;
  onSave: (level: LevelDefinition) => void;
  onCancel: () => void;
}

type EditorTool = 'walkable' | 'obstacle' | 'collectible' | 'start' | 'goal' | 'erase';

export const LevelEditor: React.FC<LevelEditorProps> = ({ 
  initialLevel, 
  onSave, 
  onCancel 
}) => {
  const [level, setLevel] = React.useState<Partial<LevelDefinition>>({
    id: '',
    name: 'Êñ∞ÂÖ≥Âç°',
    width: 8,
    height: 6,
    tiles: [],
    start: { x: 0, y: 0, facing: 'east' },
    goal: { reach: { x: 7, y: 5 } },
    bestSteps: 10,
    hints: ['Â∞ùËØïÂêëÂâçÁßªÂä®', 'Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶Ê≠£Á°Æ', '‰ΩøÁî®ÈáçÂ§çÁßØÊú®‰ºòÂåñÊ≠•Êï∞'],
    ...initialLevel
  });

  const [selectedTool, setSelectedTool] = React.useState<EditorTool>('walkable');
  const [isDrawing, setIsDrawing] = React.useState(false);
  const canvasRef = React.useRef<HTMLCanvasElement>(null);

  const CELL_SIZE = 50;
  const CANVAS_WIDTH = (level.width || 8) * CELL_SIZE;
  const CANVAS_HEIGHT = (level.height || 6) * CELL_SIZE;

  // Ëé∑ÂèñÊåáÂÆö‰ΩçÁΩÆÁöÑÁì¶Áâá
  const getTileAt = React.useCallback((x: number, y: number): Tile | undefined => {
    return level.tiles?.find(tile => tile.x === x && tile.y === y);
  }, [level.tiles]);

  // ËÆæÁΩÆÁì¶Áâá
  const setTileAt = React.useCallback((x: number, y: number, tileData: Partial<Tile>) => {
    setLevel(prev => {
      const tiles = prev.tiles || [];
      const existingIndex = tiles.findIndex(tile => tile.x === x && tile.y === y);
      
      if (existingIndex >= 0) {
        // Êõ¥Êñ∞Áé∞ÊúâÁì¶Áâá
        const newTiles = [...tiles];
        newTiles[existingIndex] = { ...newTiles[existingIndex], ...tileData };
        return { ...prev, tiles: newTiles };
      } else {
        // ÂàõÂª∫Êñ∞Áì¶Áâá
        const newTile: Tile = {
          x,
          y,
          walkable: true,
          ...tileData
        };
        return { ...prev, tiles: [...tiles, newTile] };
      }
    });
  }, []);

  // Âà†Èô§Áì¶Áâá
  const removeTileAt = React.useCallback((x: number, y: number) => {
    setLevel(prev => ({
      ...prev,
      tiles: (prev.tiles || []).filter(tile => !(tile.x === x && tile.y === y))
    }));
  }, []);

  // ÁªòÂà∂ÂÖ≥Âç°Âú∫ÊôØ
  const drawLevel = React.useCallback((ctx: CanvasRenderingContext2D) => {
    // Ê∏ÖÁ©∫ÁîªÂ∏É
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    const width = level.width || 8;
    const height = level.height || 6;

    // ÁªòÂà∂ÁΩëÊ†º
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    for (let x = 0; x <= width; x++) {
      ctx.beginPath();
      ctx.moveTo(x * CELL_SIZE, 0);
      ctx.lineTo(x * CELL_SIZE, height * CELL_SIZE);
      ctx.stroke();
    }
    for (let y = 0; y <= height; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * CELL_SIZE);
      ctx.lineTo(width * CELL_SIZE, y * CELL_SIZE);
      ctx.stroke();
    }

    // ÁªòÂà∂ÊâÄÊúâÊ†ºÂ≠ê
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height; y++) {
        const tile = getTileAt(x, y);
        const pixelX = x * CELL_SIZE;
        const pixelY = y * CELL_SIZE;

        if (tile) {
          if (tile.walkable) {
            // ÂèØË°åËµ∞Âå∫Âüü
            ctx.fillStyle = '#e8f5e8';
            ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
          } else {
            // ÈöúÁ¢çÁâ©
            ctx.fillStyle = '#424242';
            ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
          }

          // Êî∂ÈõÜÁâ©
          if (tile.collectible) {
            ctx.fillStyle = '#ffc107';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚≠ê', pixelX + CELL_SIZE / 2, pixelY + CELL_SIZE / 2);
          }
        } else {
          // Á©∫ÁôΩÂå∫Âüü
          ctx.fillStyle = '#f5f5f5';
          ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    // ÁªòÂà∂Ëµ∑Âßã‰ΩçÁΩÆ
    if (level.start) {
      const startX = level.start.x * CELL_SIZE;
      const startY = level.start.y * CELL_SIZE;
      
      ctx.fillStyle = '#2196f3';
      ctx.beginPath();
      ctx.arc(startX + CELL_SIZE / 2, startY + CELL_SIZE / 2, CELL_SIZE / 3, 0, 2 * Math.PI);
      ctx.fill();

      // ÊñπÂêëÊåáÁ§∫
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const directionEmoji = {
        north: '‚¨ÜÔ∏è',
        south: '‚¨áÔ∏è',
        east: '‚û°Ô∏è',
        west: '‚¨ÖÔ∏è'
      }[level.start.facing];
      ctx.fillText(directionEmoji, startX + CELL_SIZE / 2, startY + CELL_SIZE / 2);
    }

    // ÁªòÂà∂ÁõÆÊ†á‰ΩçÁΩÆ
    if (level.goal?.reach) {
      const goalX = level.goal.reach.x * CELL_SIZE;
      const goalY = level.goal.reach.y * CELL_SIZE;
      
      ctx.fillStyle = '#4caf50';
      ctx.globalAlpha = 0.3;
      ctx.fillRect(goalX, goalY, CELL_SIZE, CELL_SIZE);
      ctx.globalAlpha = 1;
      
      ctx.fillStyle = '#2e7d32';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üèÅ', goalX + CELL_SIZE / 2, goalY + CELL_SIZE / 2);
    }
  }, [level, getTileAt, CANVAS_WIDTH, CANVAS_HEIGHT, CELL_SIZE]);

  // Â§ÑÁêÜÁîªÂ∏ÉÁÇπÂáª
  const handleCanvasClick = React.useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
    const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

    const width = level.width || 8;
    const height = level.height || 6;

    if (x < 0 || x >= width || y < 0 || y >= height) return;

    switch (selectedTool) {
      case 'walkable':
        setTileAt(x, y, { walkable: true, collectible: undefined });
        break;
      case 'obstacle':
        setTileAt(x, y, { walkable: false, collectible: undefined });
        break;
      case 'collectible':
        setTileAt(x, y, { walkable: true, collectible: 'star' });
        break;
      case 'start':
        setLevel(prev => ({ ...prev, start: { x, y, facing: 'east' } }));
        break;
      case 'goal':
        setLevel(prev => ({ 
          ...prev, 
          goal: { ...prev.goal, reach: { x, y } }
        }));
        break;
      case 'erase':
        removeTileAt(x, y);
        break;
    }
  }, [selectedTool, level.width, level.height, setTileAt, removeTileAt, CELL_SIZE]);

  // ÁªòÂà∂Âú∫ÊôØ
  React.useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    drawLevel(ctx);
  }, [drawLevel]);

  // ‰øùÂ≠òÂÖ≥Âç°
  const handleSave = () => {
    if (!level.id || !level.name) {
      alert('ËØ∑Â°´ÂÜôÂÖ≥Âç°IDÂíåÂêçÁß∞');
      return;
    }

    const completeLevel: LevelDefinition = {
      id: level.id,
      name: level.name,
      width: level.width || 8,
      height: level.height || 6,
      tiles: level.tiles || [],
      start: level.start || { x: 0, y: 0, facing: 'east' },
      goal: level.goal || {},
      bestSteps: level.bestSteps || 10,
      hints: level.hints || []
    };

    onSave(completeLevel);
  };

  // Ê∏ÖÁ©∫ÂÖ≥Âç°
  const handleClear = () => {
    if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÂÖ≥Âç°ÂêóÔºü')) {
      setLevel(prev => ({ ...prev, tiles: [] }));
    }
  };

  return (
    <div className="level-editor">
      <style>{`
        .level-editor {
          display: grid;
          grid-template-columns: 300px 1fr;
          height: 100vh;
          font-family: 'Microsoft YaHei', sans-serif;
        }

        .editor-sidebar {
          background: #f5f5f5;
          padding: 20px;
          overflow-y: auto;
        }

        .editor-main {
          padding: 20px;
          display: flex;
          flex-direction: column;
          align-items: center;
        }

        .form-group {
          margin-bottom: 16px;
        }

        .form-group label {
          display: block;
          margin-bottom: 4px;
          font-weight: 500;
          color: #333;
        }

        .form-group input, .form-group textarea {
          width: 100%;
          padding: 8px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
        }

        .form-group textarea {
          height: 80px;
          resize: vertical;
        }

        .size-inputs {
          display: flex;
          gap: 8px;
        }

        .size-inputs input {
          flex: 1;
        }

        .tool-section {
          margin-bottom: 20px;
        }

        .tool-section h4 {
          margin: 0 0 12px 0;
          color: #333;
        }

        .tool-grid {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 8px;
        }

        .tool-btn {
          padding: 10px;
          border: 2px solid #ddd;
          border-radius: 6px;
          background: white;
          cursor: pointer;
          text-align: center;
          font-size: 12px;
          transition: all 0.2s;
        }

        .tool-btn:hover {
          border-color: #2196f3;
        }

        .tool-btn.active {
          border-color: #2196f3;
          background: #e3f2fd;
          color: #1976d2;
        }

        .tool-icon {
          display: block;
          font-size: 20px;
          margin-bottom: 4px;
        }

        .action-buttons {
          display: flex;
          flex-direction: column;
          gap: 8px;
          margin-top: 20px;
        }

        .btn {
          padding: 10px 16px;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-weight: 500;
          transition: background-color 0.2s;
        }

        .btn-primary {
          background: #4caf50;
          color: white;
        }

        .btn-primary:hover {
          background: #45a049;
        }

        .btn-secondary {
          background: #f44336;
          color: white;
        }

        .btn-secondary:hover {
          background: #da190b;
        }

        .btn-outline {
          background: white;
          color: #666;
          border: 1px solid #ddd;
        }

        .btn-outline:hover {
          background: #f5f5f5;
        }

        .editor-canvas {
          border: 2px solid #333;
          border-radius: 8px;
          cursor: crosshair;
          box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .canvas-info {
          margin-top: 16px;
          text-align: center;
          color: #666;
          font-size: 14px;
        }

        .hints-list {
          list-style: none;
          padding: 0;
        }

        .hints-list li {
          background: #f0f0f0;
          padding: 8px;
          margin: 4px 0;
          border-radius: 4px;
          font-size: 12px;
        }
      `}</style>

      {/* ‰æßËæπÊ†è */}
      <div className="editor-sidebar">
        <h3>ÂÖ≥Âç°ËÆæÁΩÆ</h3>
        
        <div className="form-group">
          <label>ÂÖ≥Âç°ID</label>
          <input
            type="text"
            value={level.id || ''}
            onChange={(e: any) => setLevel((prev: any) => ({ ...prev, id: e.target.value }))}
            placeholder="level-001"
          />
        </div>

        <div className="form-group">
          <label>ÂÖ≥Âç°ÂêçÁß∞</label>
          <input
            type="text"
            value={level.name || ''}
            onChange={(e: any) => setLevel((prev: any) => ({ ...prev, name: e.target.value }))}
            placeholder="Á¨¨‰∏ÄÂÖ≥"
          />
        </div>

        <div className="form-group">
          <label>Âú∞ÂõæÂ∞∫ÂØ∏</label>
          <div className="size-inputs">
            <input
              type="number"
              value={level.width || 8}
              onChange={(e: any) => setLevel((prev: any) => ({ ...prev, width: parseInt(e.target.value) || 8 }))}
              placeholder="ÂÆΩÂ∫¶"
              min="3"
              max="20"
            />
            <input
              type="number"
              value={level.height || 6}
              onChange={(e: any) => setLevel((prev: any) => ({ ...prev, height: parseInt(e.target.value) || 6 }))}
              placeholder="È´òÂ∫¶"
              min="3"
              max="15"
            />
          </div>
        </div>

        <div className="form-group">
          <label>ÊúÄ‰Ω≥Ê≠•Êï∞</label>
          <input
            type="number"
            value={level.bestSteps || 10}
            onChange={(e: any) => setLevel((prev: any) => ({ ...prev, bestSteps: parseInt(e.target.value) || 10 }))}
            min="1"
          />
        </div>

        <div className="tool-section">
          <h4>üõ†Ô∏è ÁºñËæëÂ∑•ÂÖ∑</h4>
          <div className="tool-grid">
            <button
              className={`tool-btn ${selectedTool === 'walkable' ? 'active' : ''}`}
              onClick={() => setSelectedTool('walkable')}
            >
              <span className="tool-icon">‚úÖ</span>
              ÂèØË°åËµ∞
            </button>
            <button
              className={`tool-btn ${selectedTool === 'obstacle' ? 'active' : ''}`}
              onClick={() => setSelectedTool('obstacle')}
            >
              <span className="tool-icon">üö´</span>
              ÈöúÁ¢çÁâ©
            </button>
            <button
              className={`tool-btn ${selectedTool === 'collectible' ? 'active' : ''}`}
              onClick={() => setSelectedTool('collectible')}
            >
              <span className="tool-icon">‚≠ê</span>
              Êî∂ÈõÜÁâ©
            </button>
            <button
              className={`tool-btn ${selectedTool === 'start' ? 'active' : ''}`}
              onClick={() => setSelectedTool('start')}
            >
              <span className="tool-icon">üèÅ</span>
              Ëµ∑ÁÇπ
            </button>
            <button
              className={`tool-btn ${selectedTool === 'goal' ? 'active' : ''}`}
              onClick={() => setSelectedTool('goal')}
            >
              <span className="tool-icon">üéØ</span>
              ÁªàÁÇπ
            </button>
            <button
              className={`tool-btn ${selectedTool === 'erase' ? 'active' : ''}`}
              onClick={() => setSelectedTool('erase')}
            >
              <span className="tool-icon">üßπ</span>
              Êì¶Èô§
            </button>
          </div>
        </div>

        <div className="form-group">
          <label>ÊèêÁ§∫ÊñáÊú¨ (ÊØèË°å‰∏Ä‰∏™)</label>
          <textarea
            value={(level.hints || []).join('\n')}
            onChange={(e: any) => setLevel((prev: any) => ({
              ...prev,
              hints: e.target.value.split('\n').filter((h: string) => h.trim())
            }))}
            placeholder="Â∞ùËØïÂêëÂâçÁßªÂä®&#10;Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶Ê≠£Á°Æ&#10;‰ΩøÁî®ÈáçÂ§çÁßØÊú®‰ºòÂåñÊ≠•Êï∞"
          />
        </div>

        <div className="action-buttons">
          <button className="btn btn-primary" onClick={handleSave}>
            üíæ ‰øùÂ≠òÂÖ≥Âç°
          </button>
          <button className="btn btn-outline" onClick={handleClear}>
            üßπ Ê∏ÖÁ©∫Âú∞Âõæ
          </button>
          <button className="btn btn-secondary" onClick={onCancel}>
            ‚ùå ÂèñÊ∂à
          </button>
        </div>
      </div>

      {/* ‰∏ªÁºñËæëÂå∫Âüü */}
      <div className="editor-main">
        <h2>ÂÖ≥Âç°ÁºñËæëÂô®</h2>
        
        <canvas
          ref={canvasRef}
          width={CANVAS_WIDTH}
          height={CANVAS_HEIGHT}
          className="editor-canvas"
          onClick={handleCanvasClick}
        />
        
        <div className="canvas-info">
          ÁÇπÂáªÊ†ºÂ≠êÊù•ÁºñËæëÂú∞Âõæ ‚Ä¢ ÂΩìÂâçÂ∑•ÂÖ∑: <strong>{
            selectedTool === 'walkable' ? 'ÂèØË°åËµ∞Âå∫Âüü' :
            selectedTool === 'obstacle' ? 'ÈöúÁ¢çÁâ©' :
            selectedTool === 'collectible' ? 'Êî∂ÈõÜÁâ©' :
            selectedTool === 'start' ? 'Ëµ∑Âßã‰ΩçÁΩÆ' :
            selectedTool === 'goal' ? 'ÁõÆÊ†á‰ΩçÁΩÆ' : 'Êì¶Èô§'
          }</strong>
        </div>
      </div>
    </div>
  );
};
